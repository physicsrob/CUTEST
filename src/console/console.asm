; AINP CONTINUES HERE (IT COULD HAVE BEEN A "JMP" THOUGH)
IN_PSEUDO:	EQU $
	PUSH	H	;SAVE HL FM ENTRY
	LXI	H,ITAB
;
;    THIS ROUTINE PROCESSES THE I/O REQUESTS
;
IOPRC:	ANI	3	;KEEP REGISTER "A" TO FOUR VALUES
	RLC		;COMPUTE ENTRY ADDRESS
	ADD	L
	MOV	L,A	;WE HAVE ADDRESS
	JMP	DISPT	;DISPATCH TO IT
;
;
OUT_PSEUDO:	EQU	$	;PROCESS OUTPUT REQUESTS
	PUSH	H	;SAVE REGS
	LXI	H,OTAB	;POINT TO OUTPUT DISPATCH TABLE
	JMP	IOPRC	;DISPATCH FOR PROPER PSUEDO PORT

;
;   OUTPUT DEVICE TABLE
;
OTAB:	EQU $
	IFDEF OUT_0
	DW OUT_0
	ENDIF
	IFDEF OUT_1
	DW OUT_1
	ENDIF
	IFDEF OUT_2
	DW OUT_2
	ENDIF
	IFDEF OUT_3
	DW OUT_3
	ENDIF
;
;    INPUT DEVICE TABLE
;
ITAB:	EQU $
	IFDEF IN_0
	DW IN_0
	ENDIF
	IFDEF IN_1
	DW IN_1
	ENDIF
	IFDEF IN_2
	DW IN_2
	ENDIF
	IFDEF IN_3
	DW IN_3
	ENDIF
;
;
;
;   THIS ROUTINE READS A LINE FROM THE CURRENT PSEUDOPORt 
;
;  C/R   TERMINATES THE SEQUENCE ERASING ALL CHARS TO THE
;        RIGHT OF THE CURSOR
;  L/F   TERMINATES THE SEQUENCE
;  ESC   RESETS TO COMMAND MODE.
;
;  Results stored in INLIN buffer
READ_LINE:	\
	LXI	H,INLIN-1	; Pointer to char in front of input buffer
	MVI	M,7	;MAKE SURE IT IS "BELL" TO KEEP FM DEL'ING TOO FAR
	INX	H	;NOW PT TO INPUT BFR
	SHLD	INPTR	;SAVE AS STARTING PTR
	MVI	A,80	;NUMBER OF CHARS IN LINE (MAX)

; Set the buffer to a string of blanks (' ')
.reset_loop:	\
	MVI	M,' '	;BLANKS
	INX	H	;NEXT CHAR
	DCR	A	;FOR THIS COUNT
	JNZ	.reset_loop	;ENTIRE LINE

read_loop:	\
	CALL_UNTIL_NZ	SINP	; READ INPUT DEVICE
	ANI	7FH	;MAKE SURE NO X'80' BIT DURING CMND MODE
	JZ	STRTD	;IF EITHER MODE (OR CTL-@)
	MOV	B,A
	CPI	CR	;IS IT CR?
	JZ finish_line
+:	CPI	LF	;IS IT A LINEFEED
	JZ	finish_line	;YES--TERMINATE LINE AS IS
	LHLD	INPTR	;CRNT LINE PTR
	CPI	7FH	;DELETE CHR?
	JNZ	+	;NO--OK
	MVI	B,BACKS	;REPLACE IT
	DCX	H	;BACK LINE PTR UP TOO
	MVI	A,'G'-40H	;SEE IF A BELL
	CMP	M	;IS IT?
	JNZ	++	;NO--OK
	MOV	B,A	;YES--RING THE BELL THEN
+:		EQU	$	;STORE CHAR IN INPUT AREA
	MOV	M,B	;PLACE CHAR INTO LINE
	INX	H	;NEXT CHAR
+:		EQU	$	;SAVE NEW LINE PTR
	SHLD	INPTR	;SAVE PTR

	CALL	SOUT
	JMP	read_loop
finish_line:	\
	; Assume non-vdm input
	; Set INPTR to beginning of input buffer (INLIN)
	LXI	H,INLIN	;ASSUME NON-VDM INPUT
	SHLD	INPTR	;ALSO RESET PTR FOR NOW
	XCHG		;DE=ADDR
	RET

; --- Write Line Subroutine ---
; Prints a line to the current pseudoport
; HL should point to null terminated string
; -----------------------------
	IF STRINGS = TRUE
WRITE_LINE:
	MOV	A, M
	ORA	A
	RZ	; Null -- return
	CPI	LF
	JNZ	+
	CALL	CRLF
	JMP	.cont
+:	MOV	B, A
	CALL	SOUT
.cont: \
	INX	H
	JMP WRITE_LINE
	ENDIF

CRLF:	MVI	B,LF	;LINE FEED
	CALL	SOUT
	MVI	B,CR	;CARRIAGE RETURN
	CALL	SOUT
	LDA	NUCNT	;GET COUNT OF NULLS TO OUTPUT
	MOV	C,A	;SAVE COUNT IN C
-:	DCR	C
	RM		;COUNTED DOWN PAST ZERO (MAX COUNT IS X'7F')
	XRA	A	;HERE IS THE NULL
	CALL	OUTH	;OUTPUT IT
	JMP	-	;LOOP FOR NUMBER OF NULLS
;
;    OUTPUT HL AS HEX 16 BIT VALUE
;
ADOUT:	MOV	A,H	;H FIRST
	CALL	HEOUT
	MOV	A,L	;THEN L FOLLOWED BY A SPACE
;
HBOUT:	CALL	HEOUT
	CALL	SINP	;SEE IF WE SHD ESCAPE FM DUMP
	JZ	BOUT	;NO--ADD THE SPACE THEN
	ANI	7FH	;MAKE SURE ITS CLEAR OF PARITY
	JZ	COMND	;EITHER MODE (OR CTL-@)
	CPI	' '	;IS IT SPACE
	JNZ	BOUT	;NO--IGNORE THE CHAR
WTLP1:	CALL	SINP	;ON SPACE, WAIT FOR ANY OTHER CHAR
	JZ	WTLP1	;JUST LOOP AFTER A SPACE UNTIL ANY KEY PRESSED
BOUT:	MVI	B,' '
	JMP	SOUT	;PUT IT OUT
;
HEOUT:	MOV	C,A	;GET THE CHARACTER
	RRC
	RRC		;MOVE THE HIGH FOUR DOWN
	RRC
	RRC
	CALL	HEOU1	;PUT THEM OUT
	MOV	A,C	;THIS TIME THE LOW FOUR
;
HEOU1:	ANI	0FH	;FOUR ON THE FLOOR
	ADI	48	;WE WORK WITH ASCII HERE
	CPI	58	;0-9?
	JC	OUTH	;YUP!
	ADI	7	;MAKE IT A LETTER
OUTH:	MOV	B,A	;OUTPUT IT FROM REGISTER 'B'
	JMP	SOUT
